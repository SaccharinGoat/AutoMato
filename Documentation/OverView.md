# A High Level Overview For The Automato System

## Long Frames
Long Frames are used when we want to send >8 bytes of data over a can message.
To use a long frame, you must set the long frame flag on ALL can frames that are long
frames. Long frames are limited to a max of 64 Bytes (currently). Each group of long
frames must contain a unique id as the first byte, for every message.

For Example, imagine this conversation between 2 modules, the MCM and AutoStart
Autostart wants to send 3, 4 byte integers A1-A4,B1-B4,C1-C4

First AutoStart Message:
Byte[0]: Unique ID
Byte[1]: Protocol:REPLY_U4_BYTES
Byte[2]: A1
Byte[3]: A2
Byte[4]: A3
Byte[5]: A4
Byte[6]: Protocol:REPLY_U4_BYTES
Byte[7]: B1

Second AutoStart Message:
Byte[0]: Unique ID
Byte[1]: B2
Byte[2]: B3
Byte[3]: B4
Byte[4]: Protocol:REPLY_U4_BYTES
Byte[5]: C1
Byte[6]: C2
Byte[7]: C3

Third AutoStart Message:
Byte[0]: Unique ID
Byte[1]: C4

If the ending message contains 8 bytes, another message should be sent containing
just one byte, where data[0] = Unique ID. This is a current design limitation.

# MCM (Main Control Module) AKA A Raspberry Pi Running CanRed
The MCM Is meant to serve as the overseer, it handles all communication from any outside
sources and redirects it to the modules, and vise versa. It is also intended to handle running
any configuration pages, such as websites hosted on the Pi itself. One of the major things the
MCM does is also being used as a translation layer for Node-Red. Such as Node-Red sending events
to a specific module, and modules reporting back information to Node-Red, to parse and handle.

Another job of the MCM is to give new Can IDs and general UUIDs to modules that have not been
setup.

# Modules
Modules are separate microcontrollers which are meant to accomplish one task, or one small subset
of tasks effectively. They can either read data from their environment, such as air temperature
modules, and/or "write" to their environment, such as unlocking the doors, rolling up a window, etc. 

Modules should use the AutoMato library for talking to other modules, setting their name/uuid, and
setting up broadcast events.

Each Module stores a bit of information about itself, as well as its possible commands. An example
of this data is as such:

Name:
Type:
Description:
UUID: // This is AutoGenerated

Commands:
    Command1:
        Name:
        CommandID:
        ReturnedData: "uint8_t X,uint8_t Y" ???
    Command1:
        Name:
        CommandID:
        ReturnedData: "uint32_t X"


If a module starts without a stored Can ID, the module should create one where 2050 > X > 2000
Then send an empty can packet to CanRed, which will generate an available ID, then return it.

# CCM (Communications Control Module)
This is a very specific module meant for controlling and maintaining an internet connection via a SIM Card
Because of the complex nature of managing a SIM card, and controlling communications, it is officially maintained

# ASM (AutoStart Module)
This module is meant to be used to remotely start/stop a car, and lock/unlock the doors.

# Broadcast Events
The Broadcast event system is meant to be used to reduce the bandwidth on the CanBus, and allow modules
to better integrate with Node-Red, or any other main control system.

Broadcast events, in essence, are a configuration system to tell modules when they should report
and/or modify something about their environment.

For this example, imagine you have 3 modules, the MCM, a module to control the car windows, and an ambient air temp/humidity module.

A user sets up a broadcast event, that if the humidity reaches greater than 85% (aka it's raining), the windows should roll up.
The configuration would look like:

{
    event: "Roll up windows",
    type: "oneshot",
    read: {
        module: "TempSensor1",
        value: "humidity"
    },
    write: {
        module: "WindowController",
        value: "RollAllUp"
    },
    when: "humidity > 80"
};

This config would get stored on the "reader" module, aka "TempSensor1".
The reader would then parse it, and at every read of the humidity, would run the "when" clause.
If the "when" clause has been met, it would run the "write" command, which is "RollUpWindows",
the receiving module interpret that, and run the command specified.

Internally, here is how this system is structured is that is it meant to be used with Node-Red,
where when you set up a flow in Node-Red, using some value from a module, it can be parsed via
CanRed, transformed into a Broadcast event, set to the modules, and when the "when" clause is reached
do that flow, as if it were running in Node-Red.

Now, this system of using Node-Red as basically configuring the system seems ass-backwards, since you
cannot use the data to do anything special in Node-Red. But for a pre-alpha, this seems like the easiest
way to have a decent setup dashboard. Once we have increased familiarity with Node-Red, we hope to fully
integrate it into the AutoMato system. 

## Internal Events - TODO
## External Events - TODO

# Power States
S0 - Fully Powered On
S1 - Low Power Sleep, Able to Read CAN Commands
S4 - Deep Sleep, Only able to be turned in via an interrupt
S5 - Fully Powered Off  

## S0
When the car is running, all modules can be turned on and fully powered.

## S1
Modules go into S1 when they are potentially needed when a car is turned off.
Such Modules include CCM, which may need to connect to the internet when
the car is not running. 

## S4
Modules like the AutoStart module is potentially needed when the car is offline, but
doesn't really need to read CAN commands, and as such can work off of an interrupt.

## S5
Modules that are definitely not needed when the car is turned off. Such as ambient
air temperature modules.


